工厂模式实现了创建者和调用者的分离

分类：
    1.简单工厂模式
        违反了开闭原则。
        虽然某种程度不符合面向对象规则（不符合开闭原则，每次新增内容都需要在原有代码上修改），但是实际使用最多。
    2.工厂方法模式：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类.
        避免了OCP开闭原则。不用在原来的代码上修改，只需新增类即可。
        不修改已有类的前提下，通过增加新类来实现扩展。
    ​3.抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
        不可以增加产品中某一个配件，可以增加一个具体的产品族。
        抽象工厂模式用来生产不同产品族的全部产品，对于只增加产品某一部分则不适用。抽象工厂模式是工厂模式的一种升级版本。
        在有多个业务品种，业务分类时，抽象工厂能产品不同类别的一个全部产品。
        例如：生产汽车，抽象工厂模式可以生产高端汽车全部配件来组成一个高端汽车，低端汽车全部配件来组成要给低端的汽车，但是不能产生一个高端的发动机和一个低端的座椅来组成一个中等的汽车。这样会混乱。

关于抽象工厂模式
    在什么情况下应当使用抽象工厂模式
    　　1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。
    　　2.这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
    　　3.同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如：Intel主板必须使用Intel CPU、Intel芯片组）
    　　4.系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。

    抽象工厂模式的优点
        分离接口和实现
    　　客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。
        使切换产品族变得容易
    　　因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。

    抽象工厂模式的缺点
        不太容易扩展新的产品
    　　如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。

工厂模式应用场景
    JDK中的Calendar的getInstance方法
    JDBC中Connection对象的获取getConnection
    Hibernate中SessionFactory创建Session
    spring中的IOC容器创建管理bean对象的时候也是工厂模式
    XML解析时的DocumentBuilderFactory创建解析器对象
    反射中Class对象的newInstance方法。


demo0 未使用工厂模式
    未使用工厂模式的时候，调用者会依赖很多类。违反了开闭原则。
demo1_1 简单工厂模式
    虽然能通过工厂来创建对象，但是违反了开闭原则。一旦增加功能需要在原有基础上修改代码。
demo1_2 工厂方法模式
    将工厂类调整为工厂接口，需要什么类型的工厂就使用该类实现该工厂，创建相应的产品。
demo1_3 抽象工厂模式

