一、装饰模式介绍
    装饰模式（decorator）：表示动态的给一个对象添加一些新的功能（利用子类继承父类也可以实现），但是比生成子类方式更灵活。
    也叫装饰者模式或者装饰器模式
    例如：我们每个人身上穿的衣服，鞋子，领带，披风都可以理解为是对人的装饰。

    装饰模式（Decorator）也叫包装器模式（Wrapper）
    装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化
    以便增加新的具体构建类和具体装饰类。

 角色：
    Component：定义一个对象接口，可以给这些对象动态添加职责。
        真实对象和装饰者对象有相同的接口，这样客户端不用知道内部有装饰者对象（Decorator）存在的，还是以之前处理真实对象的相同方式来和装饰者对象交互。
    ConcreteComponent：是定义了一个具体的对象（例如：人），也可以给这个对象添加一些其他职责。
    Decorator：装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对Component来说，是无需知道Decorator存在的。
    ConcreteDecorator：就是具体的装饰对象了（衣服，鞋子..），它起到了给Component添加职责的功能。

装饰模式的简化
　　大多数情况下，装饰模式的实现都要比上面给出的示意性例子要简单。
　　如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。
    如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。

透明性的要求
　　装饰模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。

　　用孙悟空的例子来说，必须永远把孙悟空的所有变化都当成孙悟空来对待，而如果把老孙变成的鱼儿当成鱼儿，而不是老孙，那就被老孙骗了，而这时不应当发生的。下面的做法是对的：
        TheGreatestSage sage = new Monkey();
        TheGreatestSage bird = new Bird(sage);
    　　而下面的做法是不对的：
        Monkey sage = new Monkey();
        Bird bird = new Bird(sage);

半透明的装饰模式
　　然而，纯粹的装饰模式很难找到。装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。即便是在孙大圣的系统里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的fly()方法。再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的swim()方法。
　　这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法：
        TheGreatestSage sage = new Monkey();
        Bird bird = new Bird(sage);
        bird.fly();
　　半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。

优点：
       扩展功能强，相比继承来说更灵活。继承的话会导致子类个数增加。而装饰者模式不会出现这种情况。
       可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象。
       具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的构件子类和具体装饰类。

缺点：
        产生很多小对象，大量小对象会占据内存。一定程度上影响了性能。
        装饰模式易于出错，调试排查比较麻烦。

开发中应用的场景：
        IO中输入流和输出流
        Swing包中图形界面构件功能
        Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper,增强了request对象的功能。
        Struts2中，request，response，session对象的处理。

demo1_1
    汽车基本的行为是移动，增加其功能：天上飞、水里游

demo1_2
    孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。
    本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；
    ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；
    Decorator的角色由大圣的七十二变扮演。
    而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化。

    “大圣本尊”是ConcreteComponent类，而“鸟儿”、“鱼儿”是装饰类。
    要装饰的是“大圣本尊”，也即“猢狲”实例。
    上面的例子中，系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。
demo2_1
    在JAVA I/O库中的应用

扩展：
    半透明的装饰模式：
        装饰模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。
    　　理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。
    　　装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。
            相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。
    　　在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。
    　　显然，半透明的装饰模式实际上就是处于适配器模式与装饰模式之间的灰色地带。如果将装饰模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰模式倒可以成为这种合并后的“包装模式”的代表。
        【图1.png】

装饰模式在JAVA I/O库中的应用
    装饰模式在Java语言中的最著名的应用莫过于Java I/O标准库的设计了。
    由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。
    而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java I/O库的基本模式。

    Java I/O库的对象结构图如下，由于Java I/O的对象众多，因此只画出InputStream的部分。【如图2.png】

    根据上图可以看出：
    　　●抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。
    　　●具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。
    　　●抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。
    　　●具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。

    InputStream类型中的装饰模式
    　　InputStream类型中的装饰模式是半透明的。
        1）为了说明这一点，不妨看一看作装饰模式的抽象构件角色的InputStream的源代码。
            这个抽象类声明了九个方法，并给出了其中八个的实现，另外一个是抽象方法，需要由子类实现。
        2）下面是作为装饰模式的抽象装饰角色FilterInputStream类的源代码。
            可以看出，FilterInputStream的接口与InputStream的接口是完全一致的。也就是说，直到这一步，还是与装饰模式相符合的。

        3）下面是具体装饰角色PushbackInputStream的源代码。
            查看源码，你会发现，这个装饰类提供了额外的方法unread()，这就意味着PushbackInputStream是一个半透明的装饰类。换言之，它破坏了理想的装饰模式的要求。
            如果客户端持有一个类型为InputStream对象的引用in的话，那么如果in的真实类型是 PushbackInputStream的话，只要客户端不需要使用unread()方法，那么客户端一般没有问题。
            但是如果客户端必须使用这个方法，就 必须进行向下类型转换。将in的类型转换成为PushbackInputStream之后才可能调用这个方法。
            但是，这个类型转换意味着客户端必须知道它 拿到的引用是指向一个类型为PushbackInputStream的对象。这就破坏了使用装饰模式的原始用意。

            现实世界与理论总归是有一段差距的。纯粹的装饰模式在真实的系统中很难找到。一般所遇到的，都是这种半透明的装饰模式。
        4）使用I/O流读取文件内容的简单操作示例
              观察上面的代码，会发现最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了DataInputStream对象进行处理，这个过程其实就是装饰器的组装过程，
              FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。