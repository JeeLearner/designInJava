单例模式：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。

优点：
    1.只生成一个实例，系统开销比较小
    2.单例模式可以在系统设置全局的访问点，优化共享资源的访问。

常见分类：
    主要：
        饿汉式（线程安全，调用效率高，但是不能延时加载）
        懒汉式（线程安全，调用效率不高，但是可以延时加载）
    其他：
        双重检测锁式,又叫双重检查加锁（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
        静态内部类式，又叫Lazy initialization holder class模式（线程安全，调用效率高。可以延时加载）
        枚举单例（线程安全，调用效率高，不能延时加载）

说明：
    1）饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。
    2）懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间
    3）可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？
       所谓“双重检查加锁”机制，指的是：并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。
       “双重检查加锁”机制的实现会使用关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。
       这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。

       注意：在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java5及以上的版本。
       提示：由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。
    4）要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。
      　　如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？
        一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。
    5）按照《高效Java 第二版》中的说法：单元素的枚举类型已经成为实现Singleton的最佳方法。
        用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。
        好处：使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。

扩展：
    1）关于静态内部类
        　　简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。
        　　类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。
        　　类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。
        　　类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。
    2）多线程缺省同步锁的知识
         大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括：
        　　1.由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时
        　　2.访问final字段时
        　　3.在创建线程之前创建对象时
        　　4.线程可以看见它将要处理的对象时

破解单例模式：
    a、通过反射破解（不包括枚举，因为枚举本身是单例，是由JVM管理的）
    b、通过反序列化



demo1_1 饿汉式、懒汉式、双重检查加锁、静态内部类式、枚举

    关于静态内部类式：
        当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；
        而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，
        由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。
    　　这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。

demo1_2 破解单例模式

demo1_3 测试几种单例模式的速度

