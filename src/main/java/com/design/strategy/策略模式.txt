一、策略模式介绍
    策略模式：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。
      策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。
      策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。
      用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。

    例如：
        商场中的收银软件，内部是怎么针对不同的商品打不同的折扣呢？又或者，是怎么根据不同会员等级打不同的折扣呢？
        其实内部就是定义了一个算法家族，给每个会员或者商品都指定一个特定的算法，根据不同的算法，打不同的折扣。

角色：
    Strategy（抽象算法接口）：定义了所有支持算法的公共接口
    ConcreteStrategyA、ConcreteStrategyB和ConcreteStrategyC：继承于Strategy，封装了具体的算法
    Context（上下文，又叫环境角色）：持有一个Strategy的引用。用来维护不同对象的不同算法实现

策略模式本质：
    分离算法，选择不同的实现。

策略模式的优点
　　（1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。
　　（2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

策略模式的缺点
　　（1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。
　　（2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。

三、应用场景
    JAVASE的布局管理
    Spring框架中，Resource接口，资源访问策略
        Resource接口有一些不同的实现类，主要有：
            UrlResource：访问网络资源的实现类。
            ClassPathResource：访问类路径资源。
            FileSystemResource：访问文件系统资源。
            ServletContextResource：访问相对于ServletContext路径下的资源的实现类。
            InputStreamResource：访问输入流资源的实现类。
            ByteArrayResource：访问字节数组资源。
    javax.servlet.http.HttpServlet#service();

策略模式扩展认识：
    策略模式的重心
    　　策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。

    算法的平等性
    　　策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。
    　　所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。

    运行时策略的唯一性
    　　运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。

    公有的行为
    　　经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。
    　　这其实也是典型的将代码向继承等级结构的上方集中的标准做法。